# 阿⾥⼀⾯

## 说⼀下ArrayList和LinkedList区别

```java
1. ⾸先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的
2. 由于底层数据结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合删
除和添加，查询、添加、删除的时间复杂度不同
3. 另外ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以
LinkedList还可以当做队列来使⽤
```



## 说⼀下HashMap的Put⽅法

```java
先说HashMap的Put⽅法的⼤体流程：
1. 根据Key通过哈希算法与与运算得出数组下标
2. 如果数组下标位置元素为空，则将key和value封装为Entry对象（JDK1.7中是Entry对象，JDK1.8中是
Node对象）并放⼊该位置
3. 如果数组下标位置元素不为空，则要分情况讨论
    a. 如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进⾏扩容，如果不⽤扩容就⽣成Entry对
    象，并使⽤头插法添加到当前位置的链表中
    b. 如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红⿊树Node，还是链表Node
        i. 如果是红⿊树Node，则将key和value封装为⼀个红⿊树节点并添加到红⿊树中去，在这个过
        	程中会判断红⿊树中是否存在当前key，如果存在则更新value
        ii. 如果此位置上的Node对象是链表节点，则将key和value封装为⼀个链表Node并通过尾插法插
            ⼊到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否
            存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插⼊到链表中，插⼊
            到链表后，会看当前链表的节点个数，如果⼤于等于8，那么则会将该链表转成红⿊树
        iii. 将key和value封装为Node插⼊到链表或红⿊树中后，再判断是否需要进⾏扩容，如果需要就
        	扩容，如果不需要就结束PUT⽅法
```



## 说⼀下ThreadLocal

```
1. ThreadLocal是Java中所提供的线程本地存储机制，可以利⽤该机制将数据缓存在某个线程内部，该线
    程可以在任意时刻、任意⽅法中获取缓存的数据
2. ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal
    对象）中都存在⼀个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓
    存的值
3. 如果在线程池中使⽤ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使⽤完之后，应该
    要把设置的key，value，也就是Entry对象进⾏回收，但线程池中的线程不会回收，⽽线程对象
    是通过强引⽤指向ThreadLocalMap，ThreadLocalMap也是通过强引⽤指向Entry对象，线程
    不被回收，Entry对象也就不会被回收，从⽽出现内存泄漏，解决办法是，在使⽤了
    ThreadLocal对象之后，⼿动调⽤ThreadLocal的remove⽅法，⼿动清楚Entry对象
4. ThreadLocal经典的应⽤场景就是连接管理（⼀个线程持有⼀个连接，该连接对象可以在不同的⽅法之
    间进⾏传递，线程之间不共享同⼀个连接）
```

![image-20210704174301516](C:/Users/msksn/AppData/Roaming/Typora/typora-user-images/image-20210704174301516.png)



## 说⼀下JVM中，哪些是共享区，哪些可以作为gc root

```
1、堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的
2、什么是gc root，JVM在进⾏垃圾回收时，需要找到“垃圾”对象，也就是没有被引⽤的对象，但是直接
找“垃圾”对象是⽐较耗时的，所以反过来，先找“⾮垃圾”对象，也就是正常对象，那么就需要从某
些“根”开始去找，根据这些“根”的引⽤路径找到正常对象，⽽这些“根”有⼀个特征，就是它只会引⽤其他
对象，⽽不会被其他对象引⽤，例如：栈中的本地变量、⽅法区中的静态变量、本地⽅法栈中的变量、正
在运⾏的线程等可以作为gc root。
```

![image-20210704174407475](C:/Users/msksn/AppData/Roaming/Typora/typora-user-images/image-20210704174407475.png)



## 你们项⽬如何排查JVM问题

```
对于还在正常运⾏的系统：
1. 可以使⽤jmap来查看JVM中各个区域的使⽤情况
2. 可以通过jstack来查看线程的运⾏情况，⽐如哪些线程阻塞、是否出现了死锁
3. 可以通过jstat命令来查看垃圾回收的情况，特别是fullgc，如果发现fullgc⽐较频繁，那么就得进⾏调
优了
4. 通过各个命令的结果，或者jvisualvm等⼯具来进⾏分析
5. ⾸先，初步猜测频繁发送fullgc的原因，如果频繁发⽣fullgc但是⼜⼀直没有出现内存溢出，那么表示
fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对
象进⼊到⽼年代，对于这种情况，就要考虑这些存活时间不⻓的对象是不是⽐较⼤，导致年轻代放不
下，直接进⼊到了⽼年代，尝试加⼤年轻代的⼤⼩，如果改完之后，fullgc减少，则证明修改有效
6. 同时，还可以找到占⽤CPU最多的线程，定位到具体的⽅法，优化这个⽅法的执⾏，看是否能避免某些
对象的创建，从⽽节省内存

对于已经发⽣了OOM的系统：
1. ⼀般⽣产系统中都会设置当系统发⽣了OOM时，⽣成当时的dump⽂件（-
XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base）
2. 我们可以利⽤jsisualvm等⼯具来分析dump⽂件
3. 根据dump⽂件找到异常的实例对象，和异常的线程（占⽤CPU⾼），定位到具体的代码
4. 然后再进⾏详细的分析和调试
总之，调优不是⼀蹴⽽就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题
```



## 如何查看线程死锁

1. 可以通过jstack命令来进⾏查看，jstack命令中会显示发⽣了死锁的线程 
2. 或者两个线程去操作数据库时，数据库发⽣了死锁，这是可以查询数据库的死锁情况

```sql
查询是否锁表
show OPEN TABLES where In_use > 0;
查询进程
show processlist;
查看正在锁的事务
 SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
查看等待锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
```



## 线程之间如何进⾏通讯的

```
1. 线程之间可以通过共享内存或基于⽹络来进⾏通信
2. 如果是通过共享内存来进⾏通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒
3. 像Java中的wait()、notify()就是阻塞和唤醒
4. 通过⽹络就⽐较简单了，通过⽹络连接将通信数据发送给对⽅，当然也要考虑到并发问题，处理⽅式就
是加锁等⽅式
```



## 介绍⼀下Spring，读过源码介绍⼀下⼤致流程

```
1. Spring是⼀个快速开发框架，Spring帮助程序员来管理对象
2. Spring的源码实现的是⾮常优秀的，设计模式的应⽤、并发安全的实现、⾯向接⼝的设计等
3. 在创建Spring容器，也就是启动Spring时：
	a. ⾸先会进⾏扫描，扫描得到所有的BeanDefinition对象，并存在⼀个Map中
    b. 然后筛选出⾮懒加载的单例BeanDefinition进⾏创建Bean，对于多例Bean不需要在启动过程中去
    进⾏创建，对于多例Bean会在每次获取Bean时利⽤BeanDefinition去创建
    c. 利⽤BeanDefinition创建Bean就是Bean的创建⽣命周期，这期间包括了合并BeanDefinition、推
    断构造⽅法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发⽣在初始
    化后这⼀步骤中
4. 单例Bean创建完了之后，Spring会发布⼀个容器启动事件
5. Spring启动结束
6. 在源码中会更复杂，⽐如源码中会提供⼀些模板⽅法，让⼦类来实现，⽐如源码中还涉及到⼀些
BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过
BenaFactoryPostProcessor来实现的，依赖注⼊就是通过BeanPostProcessor来实现的
7. 在Spring启动过程中还会去处理@Import等注解
```



## 说⼀下Spring的事务机制

```
1. Spring事务底层是基于数据库事务和AOP机制的
2. ⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个代理对象作为Bean
3. 当调⽤代理对象的⽅法时，会先判断该⽅法上是否加了@Transactional注解
4. 如果加了，那么则利⽤事务管理器创建⼀个数据库连接
5. 并且修改数据库连接的autocommit属性为false，禁⽌此连接的⾃动提交，这是实现Spring事务⾮常重
要的⼀步
6. 然后执⾏当前⽅法，⽅法中会执⾏sql
7. 执⾏完当前⽅法后，如果没有出现异常就直接提交事务
8. 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务
9. Spring事务的隔离级别对应的就是数据库的隔离级别
10. Spring事务的传播机制是Spring事务⾃⼰实现的，也是Spring事务中最复杂的
11. Spring事务的传播机制是基于数据库连接来做的，⼀个数据库连接⼀个事务，如果传播机制配置为需要
新开⼀个事务，那么实际上就是先建⽴⼀个数据库连接，在此新数据库连接上执⾏sql
```



## 什么时候@Transactional失效

```
因为Spring事务是基于代理来实现的，所以某个加了@Transactional的⽅法只有是被代理对象调⽤时，那
么这个注解才会⽣效，所以如果是被代理对象来调⽤这个⽅法，那么@Transactional是不会⽣效的。
同时如果某个⽅法是private的，那么@Transactional也会失效，因为底层cglib是基于⽗⼦类来实现的，
⼦类是不能重载⽗类的private⽅法的，所以⽆法很好的利⽤代理，也会导致@Transactianal失效
```



## Dubbo是如何做系统交互的

```
Dubbo底层是通过RPC来完成服务和服务之间的调⽤的，Dubbo⽀持很多协议，⽐如默认的dubbo协议，
⽐如http协议、⽐如rest等都是⽀持的，他们的底层所使⽤的技术是不太⼀样的，⽐如dubbo协议底层使
⽤的是netty，也可以使⽤mina，http协议底层使⽤的tomcat或jetty。

服务消费者在调⽤某个服务时，会将当前所调⽤的服务接⼝信息、当前⽅法信息、执⾏⽅法所传⼊的⼊参
信息等组装为⼀个Invocation对象，然后不同的协议通过不同的数据组织⽅式和传输⽅式将这个对象传送
给服务提供者，提供者接收到这个对象后，找到对应的服务实现，利⽤反射执⾏对应的⽅法，得到⽅法结
果后再通过⽹络响应给服务消费者。

当然，Dubbo在这个调⽤过程中还做很多其他的设计，⽐如服务容错、负载均衡、Filter机制、动态路由机
制等等，让Dubbo能处理更多企业中的需求。
```

![image-20210705100132161](C:/Users/msksn/AppData/Roaming/Typora/typora-user-images/image-20210705100132161.png)

![image-20210705100145241](C:/Users/msksn/AppData/Roaming/Typora/typora-user-images/image-20210705100145241.png)



## Dubbo的负载均衡策略

```
Dubbo⽬前⽀持：
1. 平衡加权轮询算法
2. 加权随机算法
3. ⼀致性哈希算法
4. 最⼩活跃数算法
```

 https://www.yuque.com/renyong-jmovm/kb/gwu187



## 还读过哪些框架源码介绍⼀下你还熟悉的

```
这个问题⽐较⼴泛，你即可以说：HashMap、线程池等JDK⾃带的源码，也可以说Mybatis、Spring
Boot、Spring Cloud、消息队列等开发框架或中间件的源码
```



# 阿⾥⼆⾯

## Jdk1.7到Jdk1.8 HashMap 发⽣了什么变化(底层)?

```
1. 1.7中底层是数组+链表，1.8中底层是数组+链表+红⿊树，加红⿊树的⽬的是提⾼HashMap插⼊和查询
    整体效率
2. 1.7中链表插⼊使⽤的是头插法，1.8中链表插⼊使⽤的是尾插法，因为1.8中插⼊key和value时需要判断
    链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使⽤尾插法
3. 1.7中哈希算法⽐较复杂，存在各种右移与异或运算，1.8中进⾏了简化，因为复杂的哈希算法的⽬的就
    是提⾼散列性，来提供HashMap的整体效率，⽽1.8中新增了红⿊树，所以可以适当的简化哈希算法，
    节省CPU资源
```



## Jdk1.7到Jdk1.8 java虚拟机发⽣了什么变化?

```
1.7中存在永久代，1.8中没有永久代，替换它的是元空间，元空间所占的内存不是在虚拟机内部，⽽是本地
内存空间，这么做的原因是，不管是永久代还是元空间，他们都是⽅法区的具体实现，之所以元空间所占
的内存改成本地内存，官⽅的说法是为了和JRockit统⼀，不过额外还有⼀些原因，⽐如⽅法区所存储的类
信息通常是⽐较难确定的，所以对于⽅法区的⼤⼩是⽐较难指定的，太⼩了容易出现⽅法区溢出，太⼤了
⼜会占⽤了太多虚拟机的内存空间，⽽转移到本地内存后则不会影响虚拟机所占⽤的内存
```



## 如何实现AOP，项⽬哪些地⽅⽤到了AOP

```
利⽤动态代理技术来实现AOP，⽐如JDK动态代理或Cglib动态代理，利⽤动态代理技术，可以针对某个类
⽣成代理对象，当调⽤代理对象的某个⽅法时，可以任意控制该⽅法的执⾏，⽐如可以先打印执⾏时间，
再执⾏该⽅法，并且该⽅法执⾏完成后，再次打印执⾏时间。
项⽬中，⽐如事务、权限控制、⽅法执⾏时⻓⽇志都是通过AOP技术来实现的，凡是需要对某些⽅法做统
⼀处理的都可以⽤AOP来实现，利⽤AOP可以做到业务⽆侵⼊。
```

![image-20210705100501666](C:/Users/msksn/AppData/Roaming/Typora/typora-user-images/image-20210705100501666.png)



## Spring中后置处理器的作⽤

```
Spring中的后置处理器分为BeanFactory后置处理器和Bean后置处理器，它们是Spring底层源码架构设计
中⾮常重要的⼀种机制，同时开发者也可以利⽤这两种后置处理器来进⾏扩展。BeanFactory后置处理器
表示针对BeanFactory的处理器，Spring启动过程中，会先创建出BeanFactory实例，然后利⽤
BeanFactory处理器来加⼯BeanFactory，⽐如Spring的扫描就是基于BeanFactory后置处理器来实现
的，⽽Bean后置处理器也类似，Spring在创建⼀个Bean的过程中，⾸先会实例化得到⼀个对象，然后再
利⽤Bean后置处理器来对该实例对象进⾏加⼯，⽐如我们常说的依赖注⼊就是基于⼀个Bean后置处理器
来实现的，通过该Bean后置处理器来给实例对象中加了@Autowired注解的属性⾃动赋值，还⽐如我们常
说的AOP，也是利⽤⼀个Bean后置处理器来实现的，基于原实例对象，判断是否需要进⾏AOP，如果需
要，那么就基于原实例对象进⾏动态代理，⽣成⼀个代理对象。
```

![image-20210705100538106](C:/Users/msksn/AppData/Roaming/Typora/typora-user-images/image-20210705100538106.png)

![image-20210705100549638](C:/Users/msksn/AppData/Roaming/Typora/typora-user-images/image-20210705100549638.png)



## 说说常⽤的SpringBoot注解，及其实现

```JAVA
1. @SpringBootApplication注解：这个注解标识了⼀个SpringBoot⼯程，它实际上是另外三个注解的组
合，这三个注解是：
    a. @SpringBootConfiguration：这个注解实际就是⼀个@Configuration，表示启动类也是⼀个配
    置类
    b. @EnableAutoConfiguration：向Spring容器中导⼊了⼀个Selector，⽤来加载ClassPath下
    SpringFactories中所定义的⾃动配置类，将这些⾃动加载为配置Bean
    c. @ComponentScan：标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的
    路径是启动类所在的当前⽬录
2. @Bean注解：⽤来定义Bean，类似于XML中的<bean>标签，Spring在启动时，会对加了@Bean注解
的⽅法进⾏解析，将⽅法的名字做为beanName，并通过执⾏⽅法得到bean对象
3. @Controller、@Service、@ResponseBody、@Autowired都可以说

```



## 说说你了解的分布式锁实现

```
分布式锁所要解决的问题的本质是：能够对分布在多台机器中的线程对共享资源的互斥访问。在这个原理
上可以有很多的实现⽅式：
    1. 基于Mysql，分布式环境中的线程连接同⼀个数据库，利⽤数据库中的⾏锁来达到互斥访问，但是
    Mysql的加锁和释放锁的性能会⽐较低，不适合真正的实际⽣产环境
    2. 基于Zookeeper，Zookeeper中的数据是存在内存的，所以相对于Mysql性能上是适合实际环境的，并
    且基于Zookeeper的顺序节点、临时节点、Watch机制能⾮常好的来实现的分布式锁
    3. 基于Redis，Redis中的数据也是在内存，基于Redis的消费订阅功能、数据超时时间，lua脚本等功
    能，也能很好的实现的分布式锁
```



## Redis的数据结构及使⽤场景

```
Redis的数据结构有：
    1. 字符串：可以⽤来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符
    串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式ID
    2. 哈希表：可以⽤来存储⼀些key-value对，更适合⽤来存储对象
    3. 列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似微信
    公众号、微博等消息流数据
    4. 集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，从⽽
    可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能
    5. 有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能

```



## Redis集群策略

```
Redis提供了三种集群策略：
    1. 主从模式：这种模式⽐较简单，主库可以读写，并且会和从库进⾏数据同步，这种模式下，客户端直接
    连主库或某个从库，但是但主库或从库宕机后，客户端需要⼿动修改IP，另外，这种模式也⽐较难进⾏
    扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能⽀持特⼤数据量
    2. 哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，
    然后在从库中选择⼀个库作为进的主库，另外哨兵也可以做集群，从⽽可以保证但某⼀个哨兵节点宕机
    后，还有其他哨兵节点可以继续⼯作，这种模式可以⽐较好的保证Redis集群的⾼可⽤，但是仍然不能
    很好的解决Redis的容量上限问题。
    3. Cluster模式：Cluster模式是⽤得⽐较多的模式，它⽀持多主多从，这种模式会按照key进⾏槽位的分
    配，可以使得不同的key分散到不同的主节点上，利⽤这种模式可以使得整个集群⽀持更⼤的数据容
    量，同时每个主节点可以拥有⾃⼰的多个从节点，如果该主节点宕机，会从它的从节点中选举⼀个新的
    主节点。
对于这三种模式，如果Redis要存的数据量不⼤，可以选择哨兵模式，如果Redis要存的数据量⼤，并且需
要持续的扩容，那么选择Cluster模式。
```



## Mysql数据库中，什么情况下设置了索引但⽆法使⽤?

```
1. 没有符合最左前缀原则
2. 字段进⾏了隐式数据类型转化
3. ⾛索引没有全表扫描效率⾼

```

 https://www.bilibili.com/video/BV1W64y1u761?from=search&seid=6062298215110905390



## Innodb是如何实现事务的

```
Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以⼀个update语句为例：
    1. Innodb在收到⼀个update语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在Buffer Pool中
    2. 执⾏update语句，修改Buffer Pool中的数据，也就是内存中的数据
    3. 针对update语句⽣成⼀个RedoLog对象，并存⼊LogBuffer中
    4. 针对update语句⽣成undolog⽇志，⽤于事务回滚
    5. 如果事务提交，那么则把RedoLog对象进⾏持久化，后续还有其他机制将Buffer Pool中所修改的数据
    ⻚持久化到磁盘中
    6. 如果事务回滚，则利⽤undolog⽇志进⾏回滚
```



## 聊聊你最有成就感的项⽬

```
1. 项⽬是做什么的
2. ⽤了什么技术
3. 你在项⽬中担任的职位
4. 收获了什么

```



## ⾃⼰最有挑战的项⽬、难点

```
1. 使⽤什么技术解决了什么项⽬难点
2. 使⽤什么技术优化了什么项⽬功能
3. 使⽤什么技术节省了多少成本

```



# 京东⼀⾯

## 遇到过哪些设计模式？

```
在学习⼀些框架或中间件的底层源码的时候遇到过⼀些设计模式：
1. 代理模式：Mybatis中⽤到JDK动态代理来⽣成Mapper的代理对象，在执⾏代理对象的⽅法时会去执
⾏SQL，Spring中AOP、包括@Configuration注解的底层实现也都⽤到了代理模式
2. 责任链模式：Tomcat中的Pipeline实现，以及Dubbo中的Filter机制都使⽤了责任链模式
3. ⼯⼚模式：Spring中的BeanFactory就是⼀种⼯⼚模式的实现
4. 适配器模式：Spring中的Bean销毁的⽣命周期中⽤到了适配器模式，⽤来适配各种Bean销毁逻辑的执
⾏⽅式
5. 外观模式：Tomcat中的Request和RequestFacade之间体现的就是外观模式
6. 模板⽅法模式：Spring中的refresh⽅法中就提供了给⼦类继承重写的⽅法，就⽤到了模板⽅法模式

```



## Java死锁如何避免？

```java
造成死锁的⼏个原因：
    1. ⼀个资源每次只能被⼀个线程使⽤
    2. ⼀个线程在阻塞等待某个资源时，不释放已占有资源
    3. ⼀个线程已经获得的资源，在未使⽤完之前，不能被强⾏剥夺
    4. 若⼲线程形成头尾相接的循环等待资源关系
    
这是造成死锁必须要达到的4个条件，如果要避免死锁，只需要不满⾜其中某⼀个条件即可。⽽其中前3个
条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系。

在开发过程中：
    1. 要注意加锁顺序，保证每个线程按同样的顺序进⾏加锁
    2. 要注意加锁时限，可以针对所设置⼀个超时时间
    3. 要注意死锁检查，这是⼀种预防机制，确保在第⼀时间发现死锁并进⾏解决
```



## 深拷⻉和浅拷⻉

```
深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实例
对象的引⽤。
    1. 浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所指向
    的对象，也就是浅拷⻉出来的对象，内部的类属性指向的是同⼀个对象
    2. 深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制，深拷
    ⻉出来的对象，内部的属性指向的不是同⼀个对象
```



## 如果你提交任务时，线程池队列已满，这时会发⽣什么

```
1. 如果使⽤的⽆界队列，那么可以继续提交任务时没关系的
2. 如果使⽤的有界队列，提交任务时，如果队列满了，如果核⼼线程数没有达到上限，那么则增加线程，
如果线程数已经达到了最⼤值，则使⽤拒绝策略进⾏拒绝
```



## 谈谈ConcurrentHashMap的扩容机制

```java
1.7版本
1. 1.7版本的ConcurrentHashMap是基于Segment分段实现的
2. 每个Segment相对于⼀个⼩型的HashMap
3. 每个Segment内部会进⾏扩容，和HashMap的扩容逻辑类似
4. 先⽣成新的数组，然后转移元素到新数组中
5. 扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值
    
1.8版本
1. 1.8版本的ConcurrentHashMap不再基于Segment实现
2. 当某个线程进⾏put时，如果发现ConcurrentHashMap正在进⾏扩容那么该线程⼀起进⾏扩容
3. 如果某个线程put时，发现没有正在进⾏扩容，则将key-value添加到ConcurrentHashMap中，然后
判断是否超过阈值，超过了则进⾏扩容
4. ConcurrentHashMap是⽀持多个线程同时扩容的
5. 扩容之前也先⽣成⼀个新的数组
6. 在转移元素时，先将原数组分组，将每组分给不同的线程来进⾏元素的转移，每个线程负责⼀组或多组
的元素转移⼯作
```



## Spring中Bean是线程安全的吗？

```
Spring本身并没有针对Bean做线程安全的处理，所以：
1. 如果Bean是⽆状态的，那么Bean则是线程安全的
2. 如果Bean是有状态的，那么Bean则不是线程安全的
另外，Bean是不是线程安全，跟Bean的作⽤域没有关系，Bean的作⽤域只是表示Bean的⽣命周期范围，
对于任何⽣命周期的Bean都是⼀个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。

```



## 说说你常⽤的Linux基本操作命令

```
1. 增删查改
2. 防⽕墙相关
3. ssh/scp
4. 软件下载、解压、安装
5. 修改权限
```



## Maven中Package和Install的区别

```
1. Package是打包，打成Jar或War
2. Install表示将Jar或War安装到本地仓库中
```



## 项⽬及主要负责的模块

```
平时要多了解⼀下你⽬前在做的项⽬中的核⼼模块，核⼼功能的业务与使⽤到的技术
```



## SpringCloud各组件功能，与Dubbo的区别

```java
1. Eureka：注册中⼼，⽤来进⾏服务的⾃动注册和发现
2. Ribbon：负载均衡组件，⽤来在消费者调⽤服务时进⾏负载均衡
3. Feign：基于接⼝的申明式的服务调⽤客户端，让调⽤变得更简单
4. Hystrix：断路器，负责服务容错
5. Zuul：服务⽹关，可以进⾏服务路由、服务降级、负载均衡等
6. Nacos：分布式配置中⼼以及注册中⼼
7. Sentinel：服务的熔断降级，包括限流
8. Seata：分布式事务
9. Spring Cloud Config：分布式配置中⼼
10. Spring Cloud Bus：消息总线
11. ...
    
https://www.bilibili.com/video/BV1uy4y1W7tt?from=search&seid=94459244624220142

Spring Cloud是⼀个微服务框架，提供了微服务领域中的很多功能组件，Dubbo⼀开始是⼀个RPC调⽤框
架，核⼼是解决服务调⽤间的问题，Spring Cloud是⼀个⼤⽽全的框架，Dubbo则更侧重于服务调⽤，所
以Dubbo所提供的功能没有Spring Cloud全⾯，但是Dubbo的服务调⽤性能⽐Spring Cloud⾼，不过
Spring Cloud和Dubbo并不是对⽴的，是可以结合起来⼀起使⽤的。
```



# 

## 